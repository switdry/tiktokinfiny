{"file_contents":{"replit.md":{"content":"# TikFinity Clone - TikTok LIVE Tools\n\n## Overview\nA complete TikTok LIVE streaming tools application that provides real-time interaction with TikTok streams including:\n- Real-time comment monitoring and display\n- Text-to-Speech (TTS) with 35+ remote voices (StreamElements API)\n- Sound alerts for gifts, follows, and events\n- Interactive overlays for OBS/streaming software\n- Goal tracking for followers/gifts/diamonds\n- Chatbot functionality\n- Song request integration\n\n## Project Architecture\n- **Backend**: Node.js/Express server (TypeScript)\n- **Frontend**: Static HTML/CSS/JS with compiled TypeScript\n- **TTS**: StreamElements free API with caching\n- **Real-time**: Server-Sent Events (SSE) for live updates\n- **Port**: 5000\n\n## Directory Structure\n```\n‚îú‚îÄ‚îÄ public/              # Static frontend files\n‚îÇ   ‚îú‚îÄ‚îÄ index.html       # Main HTML page\n‚îÇ   ‚îú‚îÄ‚îÄ styles.css       # Styles\n‚îÇ   ‚îú‚îÄ‚îÄ favicon.svg      # App icon\n‚îÇ   ‚îî‚îÄ‚îÄ widgets/         # Embeddable widgets for OBS\n‚îÇ       ‚îú‚îÄ‚îÄ chat.html    # Chat overlay widget\n‚îÇ       ‚îú‚îÄ‚îÄ alerts.html  # Alerts widget\n‚îÇ       ‚îî‚îÄ‚îÄ goals.html   # Goals progress widget\n‚îú‚îÄ‚îÄ src/                 # TypeScript source files\n‚îÇ   ‚îú‚îÄ‚îÄ server.ts        # Express backend server\n‚îÇ   ‚îú‚îÄ‚îÄ app.ts           # Frontend application logic\n‚îÇ   ‚îú‚îÄ‚îÄ services/        # TTS and other services\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ttsService.ts    # Server-side TTS with StreamElements\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ remoteTTS.ts     # Client-side TTS service\n‚îÇ   ‚îî‚îÄ‚îÄ types/           # TypeScript type definitions\n‚îú‚îÄ‚îÄ dist/                # Compiled JavaScript output\n‚îú‚îÄ‚îÄ cache/               # TTS audio cache\n‚îÇ   ‚îî‚îÄ‚îÄ tts/             # Cached TTS audio files\n```\n\n## Running the Application\n```bash\nnpm run dev    # Development with hot reload\nnpm run build  # Build TypeScript\nnpm start      # Production build and run\n```\n\n## API Endpoints\n- `POST /api/tiktok/start/:username` - Connect to TikTok live stream\n- `POST /api/tiktok/stop/:username` - Disconnect from stream\n- `GET /api/tiktok/events/:username` - SSE stream for real-time events\n- `GET /api/tiktok/comments/:username` - Get recent comments\n- `GET /api/tiktok/gifts/:username` - Get recent gifts\n- `GET /api/tiktok/stats/:username` - Get room stats\n- `GET /api/tts/voices` - Get available TTS voices\n- `POST /api/tts/speak` - Generate TTS audio\n\n## Widget URLs (for OBS)\n- `/widget/chat/:username` - Chat overlay\n- `/widget/alerts/:username` - Alert notifications\n- `/widget/goals/:username?type=diamonds&target=1000` - Goal progress bar\n\n## Key Features\n- Connects to TikTok LIVE streams using tiktok-live-connector v2.x\n- 20+ TTS voices via Google Translate API (free, no API key needed)\n- Audio caching for improved performance\n- Real-time SSE for instant updates\n- Multiple widget types for OBS integration\n- Gift tracking with diamond counts\n- Follower and like tracking\n\n## Recent Changes\n- 2025-12-12: Updated TikTok connector and TTS\n  - Updated tiktok-live-connector to v2.1.0 with WebcastEvent API\n  - Switched TTS from StreamElements to Google Translate (free, no auth)\n  - Fixed connection error handling to prevent server crashes\n  - Improved event handling with new library structure\n- 2024-12-12: Complete system overhaul\n  - Created embeddable widgets for OBS (chat, alerts, goals)\n  - Improved real-time event streaming with SSE\n  - Added gift and follow tracking\n  - Enhanced UI with better status indicators\n  - Added audio caching for TTS\n","path":null,"size_bytes":3543,"size_tokens":null},"src/types/index.ts":{"content":"export interface Comment {\n    user: string;\n    text: string;\n    timestamp: number;\n    profilePicUrl?: string;\n    raw?: any;\n}\n\nexport interface Gift {\n    id: string;\n    user: string;\n    giftName: string;\n    giftId: number;\n    repeatCount: number;\n    diamondCount: number;\n    timestamp: number;\n    profilePicUrl?: string;\n}\n\nexport interface Like {\n    user: string;\n    likeCount: number;\n    totalLikeCount: number;\n    timestamp: number;\n}\n\nexport interface Follow {\n    user: string;\n    timestamp: number;\n    profilePicUrl?: string;\n}\n\nexport interface Share {\n    user: string;\n    timestamp: number;\n}\n\nexport interface RoomStats {\n    viewerCount: number;\n    likeCount: number;\n    totalViewerCount: number;\n}\n\nexport interface StreamEvent {\n    type: 'comment' | 'gift' | 'like' | 'follow' | 'share' | 'roomStats' | 'connected' | 'disconnected';\n    data: Comment | Gift | Like | Follow | Share | RoomStats | { username: string };\n    timestamp: number;\n}\n\nexport interface AppState {\n    users: string[];\n    isReading: boolean;\n    commentQueue: Comment[];\n    currentReading: Comment | null;\n    tts: SpeechSynthesis | null;\n    voices: SpeechSynthesisVoice[];\n    remoteVoices: RemoteVoice[];\n    settings: TTSSettings;\n    commentCount: number;\n    giftCount: number;\n    likeCount: number;\n    viewerCount: number;\n    intervals: NodeJS.Timeout[];\n    lastCommentTimestamp: Record<string, number>;\n    gifts: Gift[];\n    eventSource: EventSource | null;\n}\n\nexport interface TTSSettings {\n    voice: SpeechSynthesisVoice | null;\n    remoteVoice: RemoteVoice | null;\n    useRemote: boolean;\n    speed: number;\n    volume: number;\n    filterMentions: boolean;\n    readUsername: boolean;\n}\n\nexport interface RemoteVoice {\n    id: string;\n    name: string;\n    language: string;\n    gender?: 'male' | 'female' | 'neutral';\n    provider: 'google' | 'elevenlabs' | 'azure' | 'streamelements' | 'custom';\n}\n\nexport interface ApiResponse<T> {\n    success: boolean;\n    data?: T;\n    error?: string;\n    message?: string;\n}\n\nexport interface CommentsResponse {\n    success: boolean;\n    comments: Comment[];\n    username: string;\n    message?: string;\n}\n\nexport interface RemoteTTSResponse {\n    success: boolean;\n    audioUrl: string;\n    format: 'mp3' | 'wav' | 'ogg';\n}\n\nexport interface AlertConfig {\n    enabled: boolean;\n    soundUrl?: string;\n    volume: number;\n    minValue?: number;\n}\n\nexport interface WidgetTheme {\n    backgroundColor: string;\n    textColor: string;\n    accentColor: string;\n    fontFamily: string;\n    fontSize: string;\n}\n","path":null,"size_bytes":2571,"size_tokens":null},"src/types/tiktok-live-connector.d.ts":{"content":"declare module 'tiktok-live-connector' {\n    export interface WebcastPushConnectionOptions {\n        enableExtendedGiftInfo?: boolean;\n    }\n\n    export class WebcastPushConnection {\n        constructor(username: string, options?: WebcastPushConnectionOptions);\n        on(event: string, callback: (data: any) => void): void;\n        off(event: string, callback: (data: any) => void): void;\n        connect(): Promise<void>;\n        disconnect(): Promise<void>;\n    }\n}\n\n","path":null,"size_bytes":471,"size_tokens":null},"README.md":{"content":"# üéµ TikTok Live Comments Reader (TypeScript)\n\nAplicaci√≥n web que lee los comentarios de TikTok Live en tiempo real usando Text-to-Speech (TTS) con soporte para voces locales y remotas.\n\n## ‚ú® Caracter√≠sticas\n\n- üì± Monitoreo de m√∫ltiples usuarios de TikTok en tiempo real\n- üîä Lectura autom√°tica de comentarios con TTS\n- üåê **Soporte para voces remotas** (mejor calidad de audio)\n- üé§ Voces locales del navegador\n- üéöÔ∏è Configuraci√≥n de voz, velocidad y volumen\n- üé® Interfaz moderna y responsiva\n- ‚ö° Actualizaci√≥n en tiempo real de comentarios\n- üîç Filtro opcional para solo leer menciones (@)\n- üíæ Sistema de cach√© para audio generado\n\n## üöÄ Instalaci√≥n\n\n### Requisitos previos\n\n- Node.js (v16 o superior)\n- npm o yarn\n- TypeScript 5.x\n\n### Pasos de instalaci√≥n\n\n1. **Instalar dependencias:**\n```bash\nnpm install\n```\n\n2. **Compilar TypeScript:**\n```bash\nnpm run build\n```\n\n3. **Iniciar el servidor:**\n```bash\nnpm start\n```\n\n4. **Abrir en el navegador:**\n   - El servidor estar√° corriendo en `http://localhost:3000`\n   - Abre tu navegador y ve a esa direcci√≥n\n\n## üìñ Uso\n\n1. **Abrir la aplicaci√≥n:**\n   - Ve a `http://localhost:3000` en tu navegador (Chrome, Edge o Safari recomendados)\n\n2. **Agregar usuarios:**\n   - Ingresa el @ del usuario de TikTok (sin el @)\n   - Haz clic en \"Agregar Usuario\"\n   - Puedes agregar m√∫ltiples usuarios\n\n3. **Configurar TTS:**\n   - **Voces Locales:** Usa las voces instaladas en tu sistema\n   - **Voces Remotas:** Activa \"Usar voces remotas\" para mejor calidad\n     - Selecciona una voz remota de la lista\n     - Las voces remotas usan APIs de TTS en la nube\n   - Ajusta la velocidad (0.5x - 2.0x)\n   - Ajusta el volumen (0% - 100%)\n   - Activa/desactiva el filtro de menciones\n\n4. **Iniciar monitoreo:**\n   - Haz clic en \"Iniciar Lectura\"\n   - Los comentarios aparecer√°n en tiempo real\n   - Se leer√°n autom√°ticamente con TTS\n\n5. **Detener:**\n   - Haz clic en \"Detener\" para pausar el monitoreo\n\n## üîß Configuraci√≥n del Backend\n\nEl servidor backend (`src/server.ts`) se conecta a TikTok Live usando la librer√≠a `tiktok-live-connector` y proporciona servicios de TTS remoto.\n\n### Endpoints disponibles:\n\n#### TikTok:\n- `POST /api/tiktok/start/:username` - Iniciar monitoreo de un usuario\n- `POST /api/tiktok/stop/:username` - Detener monitoreo de un usuario\n- `GET /api/tiktok/comments/:username` - Obtener comentarios (polling)\n- `GET /api/tiktok/stream/:username` - Stream de comentarios (SSE)\n- `GET /api/tiktok/status` - Estado de conexiones activas\n- `POST /api/tiktok/stop-all` - Detener todas las conexiones\n\n#### TTS Remoto:\n- `GET /api/tts/voices` - Obtener voces remotas disponibles\n- `POST /api/tts/speak` - Generar audio desde texto\n  ```json\n  {\n    \"text\": \"Texto a leer\",\n    \"voiceId\": \"es-ES-Standard-A\",\n    \"provider\": \"google\",\n    \"speed\": 1.0,\n    \"volume\": 1.0\n  }\n  ```\n\n## üåê Voces Remotas\n\nEl sistema soporta m√∫ltiples proveedores de TTS:\n\n### Google Cloud TTS (Gratis hasta cierto l√≠mite)\n- Usa Google Translate TTS como fallback gratuito\n- No requiere API key para uso b√°sico\n- Soporta m√∫ltiples idiomas y acentos\n\n### ElevenLabs (Requiere API Key)\nPara usar ElevenLabs, configura la variable de entorno:\n```bash\nELEVENLABS_API_KEY=tu_api_key\n```\n\n### Azure Speech Services (Requiere API Key)\nPara usar Azure, configura las variables de entorno:\n```bash\nAZURE_SPEECH_KEY=tu_api_key\nAZURE_SPEECH_REGION=tu_region\n```\n\n## üõ†Ô∏è Desarrollo\n\n### Modo desarrollo con auto-reload:\n\n```bash\nnpm run dev\n```\n\n### Compilar TypeScript en modo watch:\n\n```bash\nnpm run watch\n```\n\n### Estructura del proyecto:\n\n```\ntiktok/\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ app.ts              # L√≥gica del frontend (TypeScript)\n‚îÇ   ‚îú‚îÄ‚îÄ server.ts           # Servidor backend (TypeScript)\n‚îÇ   ‚îú‚îÄ‚îÄ types/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts        # Definiciones de tipos\n‚îÇ   ‚îî‚îÄ‚îÄ services/\n‚îÇ       ‚îú‚îÄ‚îÄ remoteTTS.ts    # Cliente de TTS remoto\n‚îÇ       ‚îî‚îÄ‚îÄ ttsService.ts    # Servicio de TTS en servidor\n‚îú‚îÄ‚îÄ public/\n‚îÇ   ‚îú‚îÄ‚îÄ index.html          # Interfaz principal\n‚îÇ   ‚îî‚îÄ‚îÄ styles.css          # Estilos\n‚îú‚îÄ‚îÄ dist/                   # Archivos compilados (generado)\n‚îú‚îÄ‚îÄ cache/                  # Cach√© de audio (generado)\n‚îú‚îÄ‚îÄ tsconfig.json           # Configuraci√≥n TypeScript\n‚îú‚îÄ‚îÄ package.json            # Dependencias\n‚îî‚îÄ‚îÄ README.md               # Este archivo\n```\n\n## ‚ö†Ô∏è Notas importantes\n\n1. **API de TikTok:**\n   - Esta aplicaci√≥n usa una librer√≠a de terceros para conectarse a TikTok Live\n   - TikTok puede cambiar su API en cualquier momento\n   - Aseg√∫rate de mantener las dependencias actualizadas\n\n2. **Navegadores compatibles:**\n   - Chrome/Edge: Soporte completo de TTS local y remoto\n   - Safari: Soporte completo de TTS local y remoto\n   - Firefox: Soporte limitado de TTS local\n\n3. **Permisos:**\n   - El navegador puede pedir permiso para usar el micr√≥fono/audio\n   - Aseg√∫rate de permitir el acceso para que funcione el TTS\n\n4. **L√≠mites:**\n   - TikTok puede limitar el n√∫mero de conexiones simult√°neas\n   - Se recomienda monitorear m√°ximo 3-5 usuarios a la vez\n   - Las APIs de TTS remotas pueden tener l√≠mites de uso\n\n5. **Cach√©:**\n   - Los archivos de audio generados se guardan en `cache/tts/`\n   - Esto mejora el rendimiento y reduce llamadas a APIs\n\n## üêõ Soluci√≥n de problemas\n\n### El TTS no funciona:\n- Verifica que est√©s usando Chrome, Edge o Safari\n- Aseg√∫rate de permitir el acceso de audio en el navegador\n- Para voces locales, verifica que haya voces disponibles en tu sistema\n- Para voces remotas, verifica que el servidor est√© corriendo\n\n### No se obtienen comentarios:\n- Verifica que el usuario est√© en vivo\n- Aseg√∫rate de que el servidor backend est√© corriendo\n- Revisa la consola del navegador para errores\n- Verifica que el nombre de usuario sea correcto (sin @)\n\n### Error de conexi√≥n:\n- Verifica que el servidor est√© corriendo en el puerto 3000\n- Aseg√∫rate de que no haya un firewall bloqueando la conexi√≥n\n- Revisa los logs del servidor para m√°s detalles\n\n### Error con voces remotas:\n- Verifica que el servidor est√© corriendo\n- Revisa los logs del servidor para errores de API\n- Si usas ElevenLabs o Azure, verifica que las API keys est√©n configuradas\n\n## üìù Licencia\n\nMIT\n\n## üôè Agradecimientos\n\n- [tiktok-live-connector](https://github.com/zerodytrash/TikTok-Live-Connector) - Librer√≠a para conectar con TikTok Live\n- TypeScript - Por el sistema de tipos\n- Google Cloud TTS - Por el servicio de TTS gratuito\n","path":null,"size_bytes":6552,"size_tokens":null},"src/app.ts":{"content":"import { Comment, Gift, StreamEvent, RemoteVoice } from './types';\n\ninterface AppState {\n    username: string;\n    isConnected: boolean;\n    isReading: boolean;\n    commentQueue: Comment[];\n    currentReading: Comment | null;\n    tts: SpeechSynthesis | null;\n    voices: SpeechSynthesisVoice[];\n    remoteVoices: RemoteVoice[];\n    settings: {\n        voice: SpeechSynthesisVoice | null;\n        remoteVoice: RemoteVoice | null;\n        useRemote: boolean;\n        speed: number;\n        volume: number;\n        filterMentions: boolean;\n        readUsername: boolean;\n        ttsEnabled: boolean;\n        soundAlertsEnabled: boolean;\n    };\n    stats: {\n        viewerCount: number;\n        commentCount: number;\n        giftCount: number;\n        likeCount: number;\n    };\n    eventSource: EventSource | null;\n}\n\nconst state: AppState = {\n    username: '',\n    isConnected: false,\n    isReading: false,\n    commentQueue: [],\n    currentReading: null,\n    tts: null,\n    voices: [],\n    remoteVoices: [],\n    settings: {\n        voice: null,\n        remoteVoice: null,\n        useRemote: false,\n        speed: 1.0,\n        volume: 1.0,\n        filterMentions: false,\n        readUsername: true,\n        ttsEnabled: true,\n        soundAlertsEnabled: true\n    },\n    stats: {\n        viewerCount: 0,\n        commentCount: 0,\n        giftCount: 0,\n        likeCount: 0\n    },\n    eventSource: null\n};\n\nconst API_URL = window.location.origin;\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    console.log('üöÄ Inicializando TikFinity...');\n    initializeTTS();\n    setupEventListeners();\n    loadVoices();\n    loadRemoteVoices();\n    setupNavigation();\n});\n\nfunction initializeTTS(): void {\n    if ('speechSynthesis' in window) {\n        state.tts = window.speechSynthesis;\n    }\n}\n\nfunction loadVoices(): void {\n    const loadVoicesList = (): void => {\n        if (!state.tts) return;\n        \n        state.voices = state.tts.getVoices();\n        const voiceSelect = document.getElementById('voiceSelect') as HTMLSelectElement;\n        if (!voiceSelect) return;\n        \n        voiceSelect.innerHTML = '';\n        \n        state.voices.forEach((voice, index) => {\n            const option = document.createElement('option');\n            option.value = index.toString();\n            option.textContent = `${voice.name} (${voice.lang})`;\n            voiceSelect.appendChild(option);\n        });\n\n        if (state.voices.length > 0) {\n            state.settings.voice = state.voices[0];\n        }\n    };\n\n    loadVoicesList();\n    if (state.tts && state.tts.onvoiceschanged !== undefined) {\n        state.tts.onvoiceschanged = loadVoicesList;\n    }\n}\n\nasync function loadRemoteVoices(): Promise<void> {\n    try {\n        const response = await fetch(`${API_URL}/api/tts/voices`);\n        const data = await response.json();\n        \n        if (data.success && data.voices) {\n            state.remoteVoices = data.voices;\n            const remoteVoiceSelect = document.getElementById('remoteVoiceSelect') as HTMLSelectElement;\n            if (!remoteVoiceSelect) return;\n\n            remoteVoiceSelect.innerHTML = '';\n            \n            const grouped: Record<string, RemoteVoice[]> = {};\n            state.remoteVoices.forEach(voice => {\n                const lang = voice.language.split('-')[0];\n                if (!grouped[lang]) grouped[lang] = [];\n                grouped[lang].push(voice);\n            });\n\n            Object.entries(grouped).forEach(([lang, voices]) => {\n                const optgroup = document.createElement('optgroup');\n                optgroup.label = getLanguageName(lang);\n                voices.forEach(voice => {\n                    const option = document.createElement('option');\n                    option.value = voice.id;\n                    option.textContent = voice.name;\n                    optgroup.appendChild(option);\n                });\n                remoteVoiceSelect.appendChild(optgroup);\n            });\n\n            if (state.remoteVoices.length > 0) {\n                state.settings.remoteVoice = state.remoteVoices[0];\n            }\n        }\n    } catch (error) {\n        console.error('Error loading remote voices:', error);\n    }\n}\n\nfunction getLanguageName(code: string): string {\n    const names: Record<string, string> = {\n        'es': 'Espa√±ol', 'en': 'English', 'pt': 'Portugu√™s', 'fr': 'Fran√ßais',\n        'de': 'Deutsch', 'it': 'Italiano', 'ja': 'Êó•Êú¨Ë™û', 'ko': 'ÌïúÍµ≠Ïñ¥',\n        'zh': '‰∏≠Êñá', 'ru': '–†—É—Å—Å–∫–∏–π', 'pl': 'Polski', 'nl': 'Nederlands',\n        'sv': 'Svenska', 'nb': 'Norsk', 'tr': 'T√ºrk√ße'\n    };\n    return names[code] || code.toUpperCase();\n}\n\nfunction setupNavigation(): void {\n    const navItems = document.querySelectorAll('.nav-item');\n    const sections = document.querySelectorAll('.content-section');\n    const pageTitle = document.getElementById('pageTitle');\n\n    navItems.forEach(item => {\n        item.addEventListener('click', (e) => {\n            e.preventDefault();\n            const section = (item as HTMLElement).dataset.section;\n            \n            navItems.forEach(n => n.classList.remove('active'));\n            sections.forEach(s => s.classList.remove('active'));\n            \n            item.classList.add('active');\n            document.getElementById(section || 'dashboard')?.classList.add('active');\n            \n            if (pageTitle) {\n                pageTitle.textContent = item.textContent?.trim() || 'Dashboard';\n            }\n        });\n    });\n\n    const sidebarToggle = document.getElementById('sidebarToggle');\n    const sidebar = document.getElementById('sidebar');\n    if (sidebarToggle && sidebar) {\n        sidebarToggle.addEventListener('click', () => {\n            sidebar.classList.toggle('collapsed');\n        });\n    }\n}\n\nfunction setupEventListeners(): void {\n    const connectBtn = document.getElementById('connectBtn');\n    const usernameInput = document.getElementById('tiktokUsername') as HTMLInputElement;\n    \n    connectBtn?.addEventListener('click', () => {\n        if (state.isConnected) {\n            disconnect();\n        } else {\n            const username = usernameInput?.value.replace('@', '').trim();\n            if (username) {\n                connect(username);\n            }\n        }\n    });\n\n    usernameInput?.addEventListener('keypress', (e) => {\n        if (e.key === 'Enter') {\n            connectBtn?.click();\n        }\n    });\n\n    const ttsEnabled = document.getElementById('ttsEnabled') as HTMLInputElement;\n    ttsEnabled?.addEventListener('change', (e) => {\n        state.settings.ttsEnabled = (e.target as HTMLInputElement).checked;\n    });\n\n    const useRemoteTTS = document.getElementById('useRemoteTTS') as HTMLInputElement;\n    useRemoteTTS?.addEventListener('change', (e) => {\n        state.settings.useRemote = (e.target as HTMLInputElement).checked;\n        updateVoiceSelectVisibility();\n    });\n\n    const voiceSelect = document.getElementById('voiceSelect') as HTMLSelectElement;\n    voiceSelect?.addEventListener('change', (e) => {\n        const index = parseInt((e.target as HTMLSelectElement).value);\n        if (state.voices[index]) {\n            state.settings.voice = state.voices[index];\n        }\n    });\n\n    const remoteVoiceSelect = document.getElementById('remoteVoiceSelect') as HTMLSelectElement;\n    remoteVoiceSelect?.addEventListener('change', (e) => {\n        const voiceId = (e.target as HTMLSelectElement).value;\n        const voice = state.remoteVoices.find(v => v.id === voiceId);\n        if (voice) {\n            state.settings.remoteVoice = voice;\n        }\n    });\n\n    const speedRange = document.getElementById('speedRange') as HTMLInputElement;\n    speedRange?.addEventListener('input', (e) => {\n        state.settings.speed = parseFloat((e.target as HTMLInputElement).value);\n        const speedValue = document.getElementById('speedValue');\n        if (speedValue) speedValue.textContent = state.settings.speed.toFixed(1);\n    });\n\n    const volumeRange = document.getElementById('volumeRange') as HTMLInputElement;\n    volumeRange?.addEventListener('input', (e) => {\n        state.settings.volume = parseInt((e.target as HTMLInputElement).value) / 100;\n        const volumeValue = document.getElementById('volumeValue');\n        if (volumeValue) volumeValue.textContent = (e.target as HTMLInputElement).value;\n    });\n\n    const filterMentions = document.getElementById('filterMentions') as HTMLInputElement;\n    filterMentions?.addEventListener('change', (e) => {\n        state.settings.filterMentions = (e.target as HTMLInputElement).checked;\n    });\n\n    const readUsername = document.getElementById('readUsername') as HTMLInputElement;\n    readUsername?.addEventListener('change', (e) => {\n        state.settings.readUsername = (e.target as HTMLInputElement).checked;\n    });\n\n    const soundAlertsEnabled = document.getElementById('soundAlertsEnabled') as HTMLInputElement;\n    soundAlertsEnabled?.addEventListener('change', (e) => {\n        state.settings.soundAlertsEnabled = (e.target as HTMLInputElement).checked;\n    });\n}\n\nfunction updateVoiceSelectVisibility(): void {\n    const localContainer = document.getElementById('localVoiceContainer');\n    const remoteContainer = document.getElementById('remoteVoiceContainer');\n    \n    if (state.settings.useRemote) {\n        localContainer?.classList.add('hidden');\n        remoteContainer?.classList.remove('hidden');\n    } else {\n        localContainer?.classList.remove('hidden');\n        remoteContainer?.classList.add('hidden');\n    }\n}\n\nasync function connect(username: string): Promise<void> {\n    state.username = username;\n    updateConnectionStatus('connecting');\n    \n    try {\n        const response = await fetch(`${API_URL}/api/tiktok/start/${username}`, {\n            method: 'POST'\n        });\n        \n        const data = await response.json();\n        \n        if (data.success) {\n            state.isConnected = true;\n            updateConnectionStatus('connected');\n            startEventStream(username);\n            updateConnectButton();\n        } else {\n            updateConnectionStatus('error', data.error);\n        }\n    } catch (error) {\n        console.error('Connection error:', error);\n        updateConnectionStatus('error', 'Error de conexi√≥n');\n    }\n}\n\nasync function disconnect(): Promise<void> {\n    if (state.eventSource) {\n        state.eventSource.close();\n        state.eventSource = null;\n    }\n    \n    if (state.username) {\n        try {\n            await fetch(`${API_URL}/api/tiktok/stop/${state.username}`, {\n                method: 'POST'\n            });\n        } catch (error) {\n            console.error('Disconnect error:', error);\n        }\n    }\n    \n    state.isConnected = false;\n    state.username = '';\n    updateConnectionStatus('disconnected');\n    updateConnectButton();\n}\n\nfunction startEventStream(username: string): void {\n    state.eventSource = new EventSource(`${API_URL}/api/tiktok/events/${username}`);\n    \n    state.eventSource.onmessage = (event) => {\n        try {\n            const streamEvent: StreamEvent = JSON.parse(event.data);\n            handleStreamEvent(streamEvent);\n        } catch (error) {\n            console.error('Error parsing event:', error);\n        }\n    };\n    \n    state.eventSource.onerror = () => {\n        console.log('SSE error, reconnecting...');\n        if (state.isConnected) {\n            state.eventSource?.close();\n            setTimeout(() => {\n                if (state.isConnected && state.username) {\n                    startEventStream(state.username);\n                }\n            }, 3000);\n        }\n    };\n}\n\nfunction handleStreamEvent(event: StreamEvent): void {\n    switch (event.type) {\n        case 'comment':\n            handleComment(event.data as Comment);\n            break;\n        case 'gift':\n            handleGift(event.data as Gift);\n            break;\n        case 'like':\n            handleLike(event.data as { totalLikeCount: number });\n            break;\n        case 'roomStats':\n            handleRoomStats(event.data as { viewerCount: number });\n            break;\n        case 'connected':\n            updateConnectionStatus('connected');\n            break;\n        case 'disconnected':\n            updateConnectionStatus('disconnected');\n            break;\n    }\n}\n\nfunction handleComment(comment: Comment): void {\n    state.stats.commentCount++;\n    updateStat('commentCount', state.stats.commentCount);\n    displayComment(comment);\n    \n    if (state.settings.ttsEnabled) {\n        if (state.settings.filterMentions && !comment.text.includes('@')) {\n            return;\n        }\n        queueForTTS(comment);\n    }\n}\n\nfunction handleGift(gift: Gift): void {\n    state.stats.giftCount++;\n    updateStat('giftCount', state.stats.giftCount);\n    displayGift(gift);\n}\n\nfunction handleLike(data: { totalLikeCount: number }): void {\n    state.stats.likeCount = data.totalLikeCount;\n    updateStat('likeCount', formatNumber(state.stats.likeCount));\n}\n\nfunction handleRoomStats(stats: { viewerCount: number }): void {\n    state.stats.viewerCount = stats.viewerCount;\n    updateStat('viewerCount', formatNumber(state.stats.viewerCount));\n}\n\nfunction displayComment(comment: Comment): void {\n    const liveChat = document.getElementById('liveChat');\n    if (!liveChat) return;\n    \n    const emptyState = liveChat.querySelector('.empty-state');\n    if (emptyState) emptyState.remove();\n    \n    const messageDiv = document.createElement('div');\n    messageDiv.className = 'chat-message';\n    messageDiv.innerHTML = `\n        <div class=\"chat-avatar\" style=\"background: linear-gradient(135deg, #fe2c55, #25f4ee)\"></div>\n        <div class=\"chat-content\">\n            <span class=\"chat-user\">@${escapeHtml(comment.user)}</span>\n            <span class=\"chat-text\">${escapeHtml(comment.text)}</span>\n        </div>\n    `;\n    \n    liveChat.insertBefore(messageDiv, liveChat.firstChild);\n    \n    while (liveChat.children.length > 50) {\n        liveChat.removeChild(liveChat.lastChild!);\n    }\n}\n\nfunction displayGift(gift: Gift): void {\n    const liveChat = document.getElementById('liveChat');\n    if (!liveChat) return;\n    \n    const giftDiv = document.createElement('div');\n    giftDiv.className = 'chat-message gift-message';\n    giftDiv.innerHTML = `\n        <div class=\"gift-icon\">üéÅ</div>\n        <div class=\"chat-content\">\n            <span class=\"chat-user\">@${escapeHtml(gift.user)}</span>\n            <span class=\"gift-info\">${gift.repeatCount}x ${escapeHtml(gift.giftName)} (${gift.diamondCount} üíé)</span>\n        </div>\n    `;\n    \n    liveChat.insertBefore(giftDiv, liveChat.firstChild);\n}\n\nfunction queueForTTS(comment: Comment): void {\n    state.commentQueue.push(comment);\n    if (!state.isReading) {\n        readNextComment();\n    }\n}\n\nasync function readNextComment(): Promise<void> {\n    if (state.commentQueue.length === 0) {\n        state.isReading = false;\n        state.currentReading = null;\n        return;\n    }\n\n    state.isReading = true;\n    const comment = state.commentQueue.shift()!;\n    state.currentReading = comment;\n\n    let textToRead = comment.text;\n    if (state.settings.readUsername) {\n        textToRead = `${comment.user} dice: ${comment.text}`;\n    }\n\n    try {\n        if (state.settings.useRemote && state.settings.remoteVoice) {\n            await readWithRemoteTTS(textToRead);\n        } else {\n            await readWithLocalTTS(textToRead);\n        }\n    } catch (error) {\n        console.error('TTS error:', error);\n    }\n\n    setTimeout(() => readNextComment(), 500);\n}\n\nfunction readWithLocalTTS(text: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n        if (!state.tts) {\n            reject(new Error('TTS not available'));\n            return;\n        }\n\n        const utterance = new SpeechSynthesisUtterance(text);\n        \n        if (state.settings.voice) {\n            utterance.voice = state.settings.voice;\n        }\n        \n        utterance.rate = state.settings.speed;\n        utterance.volume = state.settings.volume;\n        \n        utterance.onend = () => resolve();\n        utterance.onerror = (e) => reject(e);\n        \n        state.tts.speak(utterance);\n    });\n}\n\nasync function readWithRemoteTTS(text: string): Promise<void> {\n    if (!state.settings.remoteVoice) return;\n\n    try {\n        const response = await fetch(`${API_URL}/api/tts/speak`, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n                text,\n                voiceId: state.settings.remoteVoice.id,\n                provider: state.settings.remoteVoice.provider,\n                speed: state.settings.speed,\n                volume: state.settings.volume\n            })\n        });\n\n        const data = await response.json();\n        \n        if (data.success && data.audioUrl) {\n            const audio = new Audio(data.audioUrl);\n            audio.volume = state.settings.volume;\n            \n            await new Promise<void>((resolve, reject) => {\n                audio.onended = () => resolve();\n                audio.onerror = () => reject(new Error('Audio playback error'));\n                audio.play().catch(reject);\n            });\n        }\n    } catch (error) {\n        console.error('Remote TTS error:', error);\n        throw error;\n    }\n}\n\nfunction updateConnectionStatus(status: string, message?: string): void {\n    const statusEl = document.getElementById('connectionStatus');\n    if (!statusEl) return;\n    \n    const dot = statusEl.querySelector('.status-dot');\n    const text = statusEl.querySelector('span:last-child');\n    \n    if (dot) {\n        dot.className = 'status-dot';\n        if (status === 'connected') {\n            dot.classList.add('connected');\n        } else if (status === 'connecting') {\n            dot.classList.add('connecting');\n        } else if (status === 'error') {\n            dot.classList.add('error');\n        }\n    }\n    \n    if (text) {\n        switch (status) {\n            case 'connected':\n                text.textContent = `Conectado a @${state.username}`;\n                break;\n            case 'connecting':\n                text.textContent = 'Conectando...';\n                break;\n            case 'disconnected':\n                text.textContent = 'Desconectado';\n                break;\n            case 'error':\n                text.textContent = message || 'Error';\n                break;\n        }\n    }\n}\n\nfunction updateConnectButton(): void {\n    const btn = document.getElementById('connectBtn');\n    const input = document.getElementById('tiktokUsername') as HTMLInputElement;\n    \n    if (btn) {\n        if (state.isConnected) {\n            btn.innerHTML = '<i class=\"fas fa-plug\"></i> Desconectar';\n            btn.classList.add('btn-danger');\n            btn.classList.remove('btn-primary');\n        } else {\n            btn.innerHTML = '<i class=\"fas fa-plug\"></i> Conectar';\n            btn.classList.remove('btn-danger');\n            btn.classList.add('btn-primary');\n        }\n    }\n    \n    if (input) {\n        input.disabled = state.isConnected;\n    }\n}\n\nfunction updateStat(id: string, value: number | string): void {\n    const el = document.getElementById(id);\n    if (el) {\n        el.textContent = typeof value === 'number' ? value.toString() : value;\n    }\n}\n\nfunction formatNumber(num: number): string {\n    if (num >= 1000000) {\n        return (num / 1000000).toFixed(1) + 'M';\n    } else if (num >= 1000) {\n        return (num / 1000).toFixed(1) + 'K';\n    }\n    return num.toString();\n}\n\nfunction escapeHtml(text: string): string {\n    const div = document.createElement('div');\n    div.textContent = text;\n    return div.innerHTML;\n}\n\nconsole.log('üì¶ TikFinity cargado');\n","path":null,"size_bytes":19759,"size_tokens":null},"src/services/remoteTTS.ts":{"content":"import { RemoteVoice, RemoteTTSResponse } from '../types';\n\n// Para el navegador, usar window.location.origin o localhost\nconst getApiUrl = (): string => {\n    if (typeof window !== 'undefined') {\n        return window.location.origin;\n    }\n    return process.env.API_URL || 'http://localhost:3000';\n};\n\nexport class RemoteTTSService {\n    private apiUrl: string;\n\n    constructor(apiUrl?: string) {\n        this.apiUrl = apiUrl || getApiUrl();\n    }\n\n    /**\n     * Obtener voces remotas disponibles\n     */\n    async getRemoteVoices(): Promise<RemoteVoice[]> {\n        try {\n            const response = await fetch(`${this.apiUrl}/api/tts/voices`);\n            if (!response.ok) {\n                throw new Error('Error al obtener voces remotas');\n            }\n            const data = await response.json();\n            return data.voices || [];\n        } catch (error) {\n            console.error('Error al obtener voces remotas:', error);\n            return this.getDefaultVoices();\n        }\n    }\n\n    /**\n     * Generar audio usando TTS remoto\n     */\n    async generateSpeech(\n        text: string,\n        voice: RemoteVoice,\n        options: {\n            speed?: number;\n            volume?: number;\n        } = {}\n    ): Promise<string> {\n        try {\n            const response = await fetch(`${this.apiUrl}/api/tts/speak`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    text,\n                    voiceId: voice.id,\n                    provider: voice.provider,\n                    speed: options.speed || 1.0,\n                    volume: options.volume || 1.0,\n                }),\n            });\n\n            if (!response.ok) {\n                throw new Error('Error al generar audio');\n            }\n\n            const data: RemoteTTSResponse = await response.json();\n            return data.audioUrl;\n        } catch (error) {\n            console.error('Error al generar speech remoto:', error);\n            throw error;\n        }\n    }\n\n    /**\n     * Voces por defecto si el servidor no est√° disponible\n     */\n    private getDefaultVoices(): RemoteVoice[] {\n        return [\n            {\n                id: 'es-ES-Standard-A',\n                name: 'Espa√±ol (Espa√±a) - Femenina',\n                language: 'es-ES',\n                gender: 'female',\n                provider: 'google',\n            },\n            {\n                id: 'es-ES-Standard-B',\n                name: 'Espa√±ol (Espa√±a) - Masculina',\n                language: 'es-ES',\n                gender: 'male',\n                provider: 'google',\n            },\n            {\n                id: 'es-MX-Standard-A',\n                name: 'Espa√±ol (M√©xico) - Femenina',\n                language: 'es-MX',\n                gender: 'female',\n                provider: 'google',\n            },\n            {\n                id: 'es-MX-Standard-B',\n                name: 'Espa√±ol (M√©xico) - Masculina',\n                language: 'es-MX',\n                gender: 'male',\n                provider: 'google',\n            },\n            {\n                id: 'es-US-Standard-A',\n                name: 'Espa√±ol (EE.UU.) - Femenina',\n                language: 'es-US',\n                gender: 'female',\n                provider: 'google',\n            },\n        ];\n    }\n}\n\n","path":null,"size_bytes":3412,"size_tokens":null},"src/services/ttsService.ts":{"content":"import { RemoteVoice } from '../types';\nimport axios from 'axios';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as crypto from 'crypto';\n\nexport class TTSService {\n    private voices: RemoteVoice[] = [];\n    private cacheDir: string;\n\n    constructor() {\n        this.cacheDir = path.join(process.cwd(), 'cache', 'tts');\n        this.ensureCacheDir();\n        this.initializeVoices();\n    }\n\n    private ensureCacheDir(): void {\n        if (!fs.existsSync(this.cacheDir)) {\n            fs.mkdirSync(this.cacheDir, { recursive: true });\n        }\n    }\n\n    private initializeVoices(): void {\n        this.voices = [\n            { id: 'es', name: 'Espa√±ol', language: 'es', gender: 'female', provider: 'google' },\n            { id: 'es-MX', name: 'Espa√±ol M√©xico', language: 'es-MX', gender: 'female', provider: 'google' },\n            { id: 'es-ES', name: 'Espa√±ol Espa√±a', language: 'es-ES', gender: 'female', provider: 'google' },\n            { id: 'en', name: 'English', language: 'en', gender: 'female', provider: 'google' },\n            { id: 'en-US', name: 'English US', language: 'en-US', gender: 'female', provider: 'google' },\n            { id: 'en-GB', name: 'English UK', language: 'en-GB', gender: 'female', provider: 'google' },\n            { id: 'pt', name: 'Portugu√™s', language: 'pt', gender: 'female', provider: 'google' },\n            { id: 'pt-BR', name: 'Portugu√™s Brasil', language: 'pt-BR', gender: 'female', provider: 'google' },\n            { id: 'fr', name: 'Fran√ßais', language: 'fr', gender: 'female', provider: 'google' },\n            { id: 'de', name: 'Deutsch', language: 'de', gender: 'female', provider: 'google' },\n            { id: 'it', name: 'Italiano', language: 'it', gender: 'female', provider: 'google' },\n            { id: 'ja', name: 'Êó•Êú¨Ë™û', language: 'ja', gender: 'female', provider: 'google' },\n            { id: 'ko', name: 'ÌïúÍµ≠Ïñ¥', language: 'ko', gender: 'female', provider: 'google' },\n            { id: 'zh-CN', name: '‰∏≠Êñá', language: 'zh-CN', gender: 'female', provider: 'google' },\n            { id: 'ru', name: '–†—É—Å—Å–∫–∏–π', language: 'ru', gender: 'female', provider: 'google' },\n            { id: 'ar', name: 'ÿßŸÑÿπÿ±ÿ®Ÿäÿ©', language: 'ar', gender: 'female', provider: 'google' },\n            { id: 'hi', name: '‡§π‡§ø‡§®‡•ç‡§¶‡•Ä', language: 'hi', gender: 'female', provider: 'google' },\n            { id: 'tr', name: 'T√ºrk√ße', language: 'tr', gender: 'female', provider: 'google' },\n            { id: 'pl', name: 'Polski', language: 'pl', gender: 'female', provider: 'google' },\n            { id: 'nl', name: 'Nederlands', language: 'nl', gender: 'female', provider: 'google' },\n        ];\n    }\n\n    async getAvailableVoices(): Promise<RemoteVoice[]> {\n        return this.voices;\n    }\n\n    async generateSpeech(\n        text: string,\n        voiceId: string,\n        _provider: string = 'google',\n        options: { speed?: number; volume?: number } = {}\n    ): Promise<string> {\n        const cacheKey = this.getCacheKey(text, voiceId, options);\n        const cachedFile = path.join(this.cacheDir, `${cacheKey}.mp3`);\n\n        if (fs.existsSync(cachedFile)) {\n            return `/cache/tts/${cacheKey}.mp3`;\n        }\n\n        try {\n            const audioUrl = await this.generateGoogleTTS(text, voiceId, cacheKey);\n            return audioUrl;\n        } catch (error) {\n            console.error('Error generating TTS:', error);\n            throw error;\n        }\n    }\n\n    private async generateGoogleTTS(text: string, lang: string, cacheKey: string): Promise<string> {\n        const cachedFile = path.join(this.cacheDir, `${cacheKey}.mp3`);\n        \n        const textChunks = this.splitTextIntoChunks(text, 200);\n        const audioBuffers: Buffer[] = [];\n\n        for (const chunk of textChunks) {\n            const url = `https://translate.google.com/translate_tts?ie=UTF-8&q=${encodeURIComponent(chunk)}&tl=${lang}&client=tw-ob`;\n            \n            try {\n                const response = await axios.get(url, { \n                    responseType: 'arraybuffer',\n                    headers: {\n                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n                        'Referer': 'https://translate.google.com/'\n                    },\n                    timeout: 10000\n                });\n                audioBuffers.push(Buffer.from(response.data));\n            } catch (error: any) {\n                console.error('Error with Google TTS chunk:', error?.message);\n                throw error;\n            }\n        }\n\n        const combinedBuffer = Buffer.concat(audioBuffers);\n        fs.writeFileSync(cachedFile, combinedBuffer);\n        return `/cache/tts/${cacheKey}.mp3`;\n    }\n\n    private splitTextIntoChunks(text: string, maxLength: number): string[] {\n        if (text.length <= maxLength) {\n            return [text];\n        }\n\n        const chunks: string[] = [];\n        const sentences = text.split(/(?<=[.!?])\\s+/);\n        let currentChunk = '';\n\n        for (const sentence of sentences) {\n            if ((currentChunk + ' ' + sentence).trim().length <= maxLength) {\n                currentChunk = (currentChunk + ' ' + sentence).trim();\n            } else {\n                if (currentChunk) {\n                    chunks.push(currentChunk);\n                }\n                if (sentence.length > maxLength) {\n                    const words = sentence.split(' ');\n                    currentChunk = '';\n                    for (const word of words) {\n                        if ((currentChunk + ' ' + word).trim().length <= maxLength) {\n                            currentChunk = (currentChunk + ' ' + word).trim();\n                        } else {\n                            if (currentChunk) {\n                                chunks.push(currentChunk);\n                            }\n                            currentChunk = word;\n                        }\n                    }\n                } else {\n                    currentChunk = sentence;\n                }\n            }\n        }\n\n        if (currentChunk) {\n            chunks.push(currentChunk);\n        }\n\n        return chunks;\n    }\n\n    private getCacheKey(text: string, voiceId: string, options: { speed?: number; volume?: number }): string {\n        const hash = crypto\n            .createHash('md5')\n            .update(`${text}-${voiceId}-${options.speed || 1.0}-${options.volume || 1.0}`)\n            .digest('hex');\n        return hash;\n    }\n\n    cleanCache(): void {\n        try {\n            const files = fs.readdirSync(this.cacheDir);\n            const now = Date.now();\n            const maxAge = 24 * 60 * 60 * 1000;\n\n            for (const file of files) {\n                const filePath = path.join(this.cacheDir, file);\n                const stats = fs.statSync(filePath);\n                if (now - stats.mtimeMs > maxAge) {\n                    fs.unlinkSync(filePath);\n                }\n            }\n        } catch (error) {\n            console.error('Error cleaning cache:', error);\n        }\n    }\n}\n","path":null,"size_bytes":7140,"size_tokens":null},"public/styles.css":{"content":"* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\n:root {\n    --primary: #ff0050;\n    --primary-dark: #cc003d;\n    --secondary: #00f2ea;\n    --bg-dark: #1a1a2e;\n    --bg-darker: #0f0f1e;\n    --bg-card: #16213e;\n    --text-primary: #ffffff;\n    --text-secondary: #b8b8b8;\n    --border-color: #2a2a3e;\n    --success: #00d4aa;\n    --warning: #ffa500;\n    --danger: #ff4757;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: var(--bg-darker);\n    color: var(--text-primary);\n    overflow-x: hidden;\n}\n\n/* Sidebar */\n.sidebar {\n    position: fixed;\n    left: 0;\n    top: 0;\n    width: 260px;\n    height: 100vh;\n    background: var(--bg-dark);\n    border-right: 1px solid var(--border-color);\n    display: flex;\n    flex-direction: column;\n    z-index: 1000;\n    transition: transform 0.3s ease;\n}\n\n.sidebar-header {\n    padding: 20px;\n    border-bottom: 1px solid var(--border-color);\n}\n\n.sidebar-header h1 {\n    font-size: 1.8em;\n    color: var(--primary);\n    margin-bottom: 5px;\n}\n\n.sidebar-header .subtitle {\n    font-size: 0.9em;\n    color: var(--text-secondary);\n}\n\n.sidebar-nav {\n    flex: 1;\n    padding: 20px 0;\n    overflow-y: auto;\n}\n\n.nav-item {\n    display: flex;\n    align-items: center;\n    padding: 15px 20px;\n    color: var(--text-secondary);\n    text-decoration: none;\n    transition: all 0.3s;\n    border-left: 3px solid transparent;\n}\n\n.nav-item:hover {\n    background: var(--bg-card);\n    color: var(--text-primary);\n}\n\n.nav-item.active {\n    background: var(--bg-card);\n    color: var(--primary);\n    border-left-color: var(--primary);\n}\n\n.nav-item i {\n    margin-right: 12px;\n    width: 20px;\n}\n\n.sidebar-footer {\n    padding: 20px;\n    border-top: 1px solid var(--border-color);\n}\n\n.connection-status {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    padding: 10px;\n    background: var(--bg-card);\n    border-radius: 8px;\n}\n\n.status-dot {\n    width: 10px;\n    height: 10px;\n    border-radius: 50%;\n    background: var(--danger);\n    animation: pulse 2s infinite;\n}\n\n.connection-status.connected .status-dot {\n    background: var(--success);\n}\n\n@keyframes pulse {\n    0%, 100% { opacity: 1; }\n    50% { opacity: 0.5; }\n}\n\n/* Main Content */\n.main-content {\n    margin-left: 260px;\n    min-height: 100vh;\n    background: var(--bg-darker);\n    transition: margin-left 0.3s ease;\n}\n\n/* Topbar */\n.topbar {\n    background: var(--bg-dark);\n    border-bottom: 1px solid var(--border-color);\n    padding: 15px 30px;\n    display: flex;\n    align-items: center;\n    gap: 20px;\n    position: sticky;\n    top: 0;\n    z-index: 100;\n}\n\n.sidebar-toggle {\n    display: none;\n    background: none;\n    border: none;\n    color: var(--text-primary);\n    font-size: 1.5em;\n    cursor: pointer;\n}\n\n.topbar-title h2 {\n    font-size: 1.5em;\n    flex: 1;\n}\n\n.topbar-actions {\n    display: flex;\n    gap: 10px;\n    align-items: center;\n}\n\n.username-input {\n    padding: 10px 15px;\n    background: var(--bg-card);\n    border: 1px solid var(--border-color);\n    border-radius: 8px;\n    color: var(--text-primary);\n    font-size: 0.9em;\n}\n\n.username-input:focus {\n    outline: none;\n    border-color: var(--primary);\n}\n\n/* Buttons */\n.btn {\n    padding: 10px 20px;\n    border: none;\n    border-radius: 8px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: all 0.3s;\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n}\n\n.btn-primary {\n    background: var(--primary);\n    color: white;\n}\n\n.btn-primary:hover {\n    background: var(--primary-dark);\n}\n\n.btn-secondary {\n    background: var(--bg-card);\n    color: var(--text-primary);\n    border: 1px solid var(--border-color);\n}\n\n.btn-secondary:hover {\n    background: var(--border-color);\n}\n\n.btn-icon {\n    background: none;\n    border: none;\n    color: var(--text-secondary);\n    cursor: pointer;\n    padding: 5px 10px;\n    border-radius: 5px;\n    transition: all 0.3s;\n}\n\n.btn-icon:hover {\n    background: var(--bg-card);\n    color: var(--text-primary);\n}\n\n/* Content Sections */\n.content-section {\n    display: none;\n    padding: 30px;\n    animation: fadeIn 0.3s ease;\n}\n\n.content-section.active {\n    display: block;\n}\n\n@keyframes fadeIn {\n    from { opacity: 0; transform: translateY(10px); }\n    to { opacity: 1; transform: translateY(0); }\n}\n\n/* Cards */\n.card {\n    background: var(--bg-card);\n    border-radius: 12px;\n    padding: 25px;\n    margin-bottom: 20px;\n    border: 1px solid var(--border-color);\n}\n\n.card h3 {\n    font-size: 1.5em;\n    margin-bottom: 10px;\n    display: flex;\n    align-items: center;\n    gap: 10px;\n}\n\n.section-description {\n    color: var(--text-secondary);\n    margin-bottom: 20px;\n}\n\n/* Dashboard */\n.dashboard-grid {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));\n    gap: 20px;\n    margin-bottom: 30px;\n}\n\n.stat-card {\n    background: var(--bg-card);\n    border-radius: 12px;\n    padding: 25px;\n    display: flex;\n    align-items: center;\n    gap: 20px;\n    border: 1px solid var(--border-color);\n    transition: transform 0.3s;\n}\n\n.stat-card:hover {\n    transform: translateY(-5px);\n}\n\n.stat-icon {\n    width: 60px;\n    height: 60px;\n    border-radius: 12px;\n    background: linear-gradient(135deg, var(--primary), var(--secondary));\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 1.5em;\n}\n\n.stat-info h3 {\n    font-size: 2em;\n    margin-bottom: 5px;\n}\n\n.stat-info p {\n    color: var(--text-secondary);\n}\n\n/* Live Chat */\n.live-chat {\n    max-height: 500px;\n    overflow-y: auto;\n    background: var(--bg-darker);\n    border-radius: 8px;\n    padding: 15px;\n}\n\n.chat-message {\n    padding: 10px;\n    margin-bottom: 10px;\n    background: var(--bg-card);\n    border-radius: 8px;\n    border-left: 3px solid var(--primary);\n    animation: slideIn 0.3s ease;\n}\n\n@keyframes slideIn {\n    from {\n        opacity: 0;\n        transform: translateX(-20px);\n    }\n    to {\n        opacity: 1;\n        transform: translateX(0);\n    }\n}\n\n.chat-user {\n    font-weight: 600;\n    color: var(--primary);\n    margin-right: 10px;\n}\n\n.chat-text {\n    color: var(--text-primary);\n}\n\n.chat-avatar {\n    width: 36px;\n    height: 36px;\n    border-radius: 50%;\n    flex-shrink: 0;\n}\n\n.chat-content {\n    flex: 1;\n    min-width: 0;\n}\n\n.chat-message {\n    display: flex;\n    align-items: flex-start;\n    gap: 12px;\n}\n\n.gift-message {\n    background: linear-gradient(135deg, rgba(255, 215, 0, 0.15), rgba(255, 140, 0, 0.15));\n    border-left-color: #ffd700;\n}\n\n.gift-icon {\n    font-size: 28px;\n    flex-shrink: 0;\n}\n\n.gift-info {\n    color: #ffd700;\n    font-weight: 500;\n}\n\n.status-dot.connected {\n    background: var(--success);\n    box-shadow: 0 0 10px var(--success);\n    animation: none;\n}\n\n.status-dot.connecting {\n    background: var(--warning);\n}\n\n.status-dot.error {\n    background: var(--danger);\n}\n\n.btn-danger {\n    background: var(--danger);\n    color: white;\n}\n\n.btn-danger:hover {\n    background: #e63946;\n}\n\n.username-input:disabled {\n    opacity: 0.6;\n    cursor: not-allowed;\n}\n\n/* Forms */\n.form-group {\n    margin-bottom: 20px;\n}\n\n.form-group label {\n    display: block;\n    margin-bottom: 8px;\n    color: var(--text-secondary);\n}\n\n.form-group input[type=\"text\"],\n.form-group input[type=\"number\"],\n.form-group input[type=\"password\"],\n.form-group select {\n    width: 100%;\n    padding: 12px;\n    background: var(--bg-darker);\n    border: 1px solid var(--border-color);\n    border-radius: 8px;\n    color: var(--text-primary);\n    font-size: 1em;\n}\n\n.form-group input[type=\"range\"] {\n    width: 100%;\n}\n\n.form-group input[type=\"checkbox\"] {\n    margin-right: 8px;\n    width: 18px;\n    height: 18px;\n    cursor: pointer;\n}\n\n/* Alerts */\n.alerts-list {\n    display: flex;\n    flex-direction: column;\n    gap: 15px;\n}\n\n.alert-item {\n    background: var(--bg-darker);\n    border-radius: 8px;\n    padding: 15px;\n    border: 1px solid var(--border-color);\n}\n\n.alert-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 10px;\n}\n\n.file-input, .url-input {\n    width: 100%;\n    padding: 10px;\n    margin-top: 10px;\n    background: var(--bg-card);\n    border: 1px solid var(--border-color);\n    border-radius: 5px;\n    color: var(--text-primary);\n}\n\n/* Overlays */\n.overlays-grid {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));\n    gap: 20px;\n}\n\n.overlay-item {\n    background: var(--bg-darker);\n    border-radius: 8px;\n    padding: 20px;\n    border: 1px solid var(--border-color);\n}\n\n.overlay-preview {\n    width: 100%;\n    height: 200px;\n    background: var(--bg-card);\n    border-radius: 8px;\n    margin-top: 15px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    color: var(--text-secondary);\n}\n\n/* Goals */\n.goals-list {\n    display: flex;\n    flex-direction: column;\n    gap: 15px;\n    margin-bottom: 20px;\n}\n\n.goal-item {\n    background: var(--bg-darker);\n    border-radius: 8px;\n    padding: 20px;\n    border: 1px solid var(--border-color);\n}\n\n.goal-header {\n    display: flex;\n    gap: 10px;\n    margin-bottom: 15px;\n}\n\n.goal-name {\n    flex: 1;\n}\n\n.goal-progress {\n    margin: 15px 0;\n}\n\n.progress-bar {\n    width: 100%;\n    height: 25px;\n    background: var(--bg-card);\n    border-radius: 12px;\n    overflow: hidden;\n    margin-bottom: 10px;\n}\n\n.progress-fill {\n    height: 100%;\n    background: linear-gradient(90deg, var(--primary), var(--secondary));\n    transition: width 0.3s ease;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    color: white;\n    font-weight: 600;\n    font-size: 0.9em;\n}\n\n.goal-stats {\n    text-align: center;\n    color: var(--text-secondary);\n}\n\n/* Chatbot */\n.chatbot-rules {\n    display: flex;\n    flex-direction: column;\n    gap: 15px;\n    margin-bottom: 20px;\n}\n\n.rule-item {\n    display: flex;\n    gap: 10px;\n    align-items: center;\n}\n\n.rule-keyword,\n.rule-response {\n    flex: 1;\n    padding: 10px;\n    background: var(--bg-darker);\n    border: 1px solid var(--border-color);\n    border-radius: 5px;\n    color: var(--text-primary);\n}\n\n/* Actions */\n.actions-list {\n    display: flex;\n    flex-direction: column;\n    gap: 15px;\n    margin-bottom: 20px;\n}\n\n.action-item {\n    background: var(--bg-darker);\n    border-radius: 8px;\n    padding: 20px;\n    border: 1px solid var(--border-color);\n}\n\n.action-header {\n    display: flex;\n    gap: 10px;\n    margin-bottom: 15px;\n}\n\n.action-trigger {\n    flex: 1;\n    padding: 10px;\n    background: var(--bg-card);\n    border: 1px solid var(--border-color);\n    border-radius: 5px;\n    color: var(--text-primary);\n}\n\n.action-config {\n    display: flex;\n    gap: 10px;\n}\n\n.action-type {\n    padding: 10px;\n    background: var(--bg-card);\n    border: 1px solid var(--border-color);\n    border-radius: 5px;\n    color: var(--text-primary);\n}\n\n.action-config-input {\n    flex: 1;\n    padding: 10px;\n    background: var(--bg-card);\n    border: 1px solid var(--border-color);\n    border-radius: 5px;\n    color: var(--text-primary);\n}\n\n/* Music Queue */\n.queue-list {\n    margin-top: 20px;\n    background: var(--bg-darker);\n    border-radius: 8px;\n    padding: 20px;\n    border: 1px solid var(--border-color);\n}\n\n.queue-empty {\n    text-align: center;\n    color: var(--text-secondary);\n    padding: 40px;\n}\n\n/* Overlay Windows */\n.overlay-windows {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100vw;\n    height: 100vh;\n    pointer-events: none;\n    z-index: 9999;\n}\n\n.overlay-window {\n    position: absolute;\n    pointer-events: auto;\n}\n\n.overlay-content {\n    background: rgba(0, 0, 0, 0.7);\n    border-radius: 8px;\n    padding: 15px;\n    color: white;\n    font-weight: 600;\n    animation: fadeIn 0.3s ease;\n}\n\n/* Utilities */\n.hidden {\n    display: none !important;\n}\n\n.empty-state {\n    text-align: center;\n    color: var(--text-secondary);\n    padding: 40px;\n    font-style: italic;\n}\n\n/* Responsive */\n@media (max-width: 768px) {\n    .sidebar {\n        transform: translateX(-100%);\n    }\n\n    .sidebar.open {\n        transform: translateX(0);\n    }\n\n    .main-content {\n        margin-left: 0;\n    }\n\n    .sidebar-toggle {\n        display: block;\n    }\n\n    .dashboard-grid {\n        grid-template-columns: 1fr;\n    }\n\n    .topbar {\n        flex-wrap: wrap;\n    }\n}\n","path":null,"size_bytes":12243,"size_tokens":null},"src/server.ts":{"content":"import express, { Request, Response } from 'express';\nimport cors from 'cors';\nimport path from 'path';\nconst { TikTokLiveConnection, WebcastEvent } = require('tiktok-live-connector');\nimport { Comment, Gift, StreamEvent, RoomStats } from './types';\nimport { TTSService } from './services/ttsService';\n\nconst app = express();\nconst PORT = process.env.PORT || 5000;\n\napp.use(cors());\napp.use(express.json());\napp.use(express.static('public'));\napp.use('/dist', express.static('dist'));\napp.use('/cache', express.static('cache'));\napp.use('/widgets', express.static('public/widgets'));\n\ninterface ActiveConnection {\n    connection: any;\n    comments: Comment[];\n    gifts: Gift[];\n    sseClients: Set<Response>;\n    roomStats: RoomStats;\n    isConnected: boolean;\n}\n\nconst activeConnections = new Map<string, ActiveConnection>();\nconst ttsService = new TTSService();\n\nfunction broadcastEvent(username: string, event: StreamEvent): void {\n    const conn = activeConnections.get(username);\n    if (conn) {\n        const eventData = JSON.stringify(event);\n        conn.sseClients.forEach(client => {\n            try {\n                client.write(`data: ${eventData}\\n\\n`);\n            } catch (e) {\n                conn.sseClients.delete(client);\n            }\n        });\n    }\n}\n\napp.get('/api/tiktok/events/:username', (req: Request, res: Response): void => {\n    const username = req.params.username.replace('@', '').trim();\n\n    res.setHeader('Content-Type', 'text/event-stream');\n    res.setHeader('Cache-Control', 'no-cache');\n    res.setHeader('Connection', 'keep-alive');\n    res.setHeader('Access-Control-Allow-Origin', '*');\n    res.setHeader('X-Accel-Buffering', 'no');\n\n    const conn = activeConnections.get(username);\n    if (conn) {\n        conn.sseClients.add(res);\n        \n        if (conn.isConnected) {\n            const event: StreamEvent = {\n                type: 'connected',\n                data: { username },\n                timestamp: Date.now()\n            };\n            res.write(`data: ${JSON.stringify(event)}\\n\\n`);\n        }\n\n        req.on('close', () => {\n            conn.sseClients.delete(res);\n        });\n    } else {\n        res.write(`data: ${JSON.stringify({ type: 'error', data: { message: 'No hay conexi√≥n activa' }, timestamp: Date.now() })}\\n\\n`);\n    }\n});\n\napp.post('/api/tiktok/start/:username', async (req: Request, res: Response): Promise<void> => {\n    const username = req.params.username.replace('@', '').trim();\n\n    if (!username) {\n        res.status(400).json({ success: false, error: 'Nombre de usuario requerido', username: '' });\n        return;\n    }\n\n    if (activeConnections.has(username)) {\n        const conn = activeConnections.get(username)!;\n        res.json({\n            success: true,\n            message: 'Ya est√° conectado',\n            username,\n            stats: conn.roomStats\n        });\n        return;\n    }\n\n    console.log(`\\nüîó [${new Date().toISOString()}] Conectando con @${username}...`);\n\n    let tiktokConnection: any = null;\n    const comments: Comment[] = [];\n    const gifts: Gift[] = [];\n    const maxItems = 100;\n    const roomStats: RoomStats = { viewerCount: 0, likeCount: 0, totalViewerCount: 0 };\n\n    try {\n        tiktokConnection = new TikTokLiveConnection(username);\n\n        const connData: ActiveConnection = {\n            connection: tiktokConnection,\n            comments,\n            gifts,\n            sseClients: new Set(),\n            roomStats,\n            isConnected: false\n        };\n        activeConnections.set(username, connData);\n\n        tiktokConnection.on(WebcastEvent.CHAT, (data: any) => {\n            try {\n                const comment: Comment = {\n                    user: data.user?.uniqueId || data.uniqueId || data.nickname || 'Usuario',\n                    text: data.comment || data.text || '',\n                    timestamp: Date.now(),\n                    profilePicUrl: data.user?.profilePicture?.urls?.[0] || data.profilePictureUrl,\n                    raw: data,\n                };\n\n                if (comment.text && comment.text.trim()) {\n                    comments.push(comment);\n                    if (comments.length > maxItems) comments.shift();\n                    \n                    console.log(`üí¨ [${username}] @${comment.user}: ${comment.text.substring(0, 50)}`);\n                    \n                    broadcastEvent(username, {\n                        type: 'comment',\n                        data: comment,\n                        timestamp: Date.now()\n                    });\n                }\n            } catch (e) {\n                console.error(`Error procesando chat:`, e);\n            }\n        });\n\n        tiktokConnection.on(WebcastEvent.GIFT, (data: any) => {\n            try {\n                const gift: Gift = {\n                    id: `${data.user?.uniqueId || data.uniqueId}-${data.giftId}-${Date.now()}`,\n                    user: data.user?.uniqueId || data.uniqueId || data.nickname || 'Usuario',\n                    giftName: data.giftName || data.gift?.name || 'Regalo',\n                    giftId: data.giftId,\n                    repeatCount: data.repeatCount || 1,\n                    diamondCount: data.diamondCount || data.gift?.diamondCount || 0,\n                    timestamp: Date.now(),\n                    profilePicUrl: data.user?.profilePicture?.urls?.[0] || data.profilePictureUrl,\n                };\n\n                if (data.repeatEnd || data.giftType === 1 || !data.repeatEnd) {\n                    gifts.push(gift);\n                    if (gifts.length > maxItems) gifts.shift();\n                    \n                    console.log(`üéÅ [${username}] @${gift.user} envi√≥ ${gift.repeatCount}x ${gift.giftName} (${gift.diamondCount} diamonds)`);\n                    \n                    broadcastEvent(username, {\n                        type: 'gift',\n                        data: gift,\n                        timestamp: Date.now()\n                    });\n                }\n            } catch (e) {\n                console.error(`Error procesando regalo:`, e);\n            }\n        });\n\n        tiktokConnection.on(WebcastEvent.LIKE, (data: any) => {\n            try {\n                connData.roomStats.likeCount = data.totalLikeCount || connData.roomStats.likeCount;\n                \n                broadcastEvent(username, {\n                    type: 'like',\n                    data: {\n                        user: data.user?.uniqueId || data.uniqueId || 'Usuario',\n                        likeCount: data.likeCount || 1,\n                        totalLikeCount: data.totalLikeCount || 0,\n                        timestamp: Date.now()\n                    },\n                    timestamp: Date.now()\n                });\n            } catch (e) {\n                console.error(`Error procesando like:`, e);\n            }\n        });\n\n        tiktokConnection.on(WebcastEvent.FOLLOW, (data: any) => {\n            try {\n                broadcastEvent(username, {\n                    type: 'follow',\n                    data: {\n                        user: data.user?.uniqueId || data.uniqueId || data.nickname || 'Usuario',\n                        timestamp: Date.now(),\n                        profilePicUrl: data.user?.profilePicture?.urls?.[0] || data.profilePictureUrl\n                    },\n                    timestamp: Date.now()\n                });\n                console.log(`üë§ [${username}] Nuevo seguidor: @${data.user?.uniqueId || data.uniqueId}`);\n            } catch (e) {\n                console.error(`Error procesando follow:`, e);\n            }\n        });\n\n        tiktokConnection.on(WebcastEvent.SHARE, (data: any) => {\n            try {\n                broadcastEvent(username, {\n                    type: 'share',\n                    data: {\n                        user: data.user?.uniqueId || data.uniqueId || 'Usuario',\n                        timestamp: Date.now()\n                    },\n                    timestamp: Date.now()\n                });\n            } catch (e) {\n                console.error(`Error procesando share:`, e);\n            }\n        });\n\n        tiktokConnection.on(WebcastEvent.ROOM_USER, (data: any) => {\n            try {\n                connData.roomStats.viewerCount = data.viewerCount || 0;\n                connData.roomStats.totalViewerCount = data.topViewers?.length || 0;\n                \n                broadcastEvent(username, {\n                    type: 'roomStats',\n                    data: connData.roomStats,\n                    timestamp: Date.now()\n                });\n            } catch (e) {\n                console.error(`Error procesando roomUser:`, e);\n            }\n        });\n\n        tiktokConnection.on(WebcastEvent.CONNECTED, (state: any) => {\n            console.log(`‚úÖ [${username}] Conectado! Room ID: ${state?.roomId}`);\n            connData.isConnected = true;\n            connData.roomStats.viewerCount = state?.viewerCount || 0;\n            \n            broadcastEvent(username, {\n                type: 'connected',\n                data: { username },\n                timestamp: Date.now()\n            });\n        });\n\n        tiktokConnection.on(WebcastEvent.STREAM_END, () => {\n            console.log(`üì∫ [${username}] Stream terminado`);\n            connData.isConnected = false;\n            broadcastEvent(username, {\n                type: 'disconnected',\n                data: { username },\n                timestamp: Date.now()\n            });\n        });\n\n        tiktokConnection.on(WebcastEvent.DISCONNECTED, () => {\n            console.log(`üîå [${username}] Desconectado`);\n            connData.isConnected = false;\n            broadcastEvent(username, {\n                type: 'disconnected',\n                data: { username },\n                timestamp: Date.now()\n            });\n        });\n\n        tiktokConnection.on(WebcastEvent.ERROR, (err: unknown) => {\n            let errorMsg = 'Unknown error';\n            try {\n                if (err instanceof Error) {\n                    errorMsg = err.message;\n                } else if (typeof err === 'object' && err !== null) {\n                    errorMsg = JSON.stringify(err);\n                } else {\n                    errorMsg = String(err);\n                }\n            } catch (e) {\n                errorMsg = 'Error parsing error';\n            }\n            console.error(`‚ùå [${username}] Error:`, errorMsg);\n        });\n\n        console.log(`‚è≥ [${username}] Intentando conectar...`);\n        \n        await Promise.race([\n            tiktokConnection.connect(),\n            new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout de conexi√≥n')), 30000))\n        ]);\n\n        console.log(`‚úÖ [${username}] Conexi√≥n establecida`);\n\n        res.json({\n            success: true,\n            message: `Conectado a @${username}`,\n            username,\n            stats: roomStats\n        });\n\n    } catch (error: unknown) {\n        let errorMessage = 'Error al conectar con TikTok';\n        let errorStr = 'Unknown error';\n        \n        try {\n            if (error instanceof Error) {\n                errorStr = error.message;\n                console.error(`‚ùå [${username}] Error completo:`, error.stack || error);\n            } else if (typeof error === 'object' && error !== null) {\n                errorStr = JSON.stringify(error, null, 2);\n                console.error(`‚ùå [${username}] Error objeto:`, error);\n            } else {\n                errorStr = String(error);\n            }\n        } catch (e) {\n            errorStr = 'Error parsing error';\n            console.error(`‚ùå [${username}] Error original:`, error);\n        }\n        \n        console.error(`‚ùå [${username}] Error al conectar:`, errorStr);\n        \n        activeConnections.delete(username);\n        \n        if (tiktokConnection) {\n            try { \n                await tiktokConnection.disconnect(); \n            } catch (disconnectError) {\n                console.error(`Error disconnecting:`, disconnectError);\n            }\n        }\n        \n        if (errorStr.toLowerCase().includes('not found') || \n            errorStr.toLowerCase().includes('roomid') ||\n            errorStr.toLowerCase().includes('offline') ||\n            errorStr.toLowerCase().includes('no live')) {\n            errorMessage = 'El usuario no est√° en vivo. Aseg√∫rate de que est√© transmitiendo.';\n        } else if (errorStr.toLowerCase().includes('timeout')) {\n            errorMessage = 'Tiempo de espera agotado. Intenta de nuevo.';\n        } else if (errorStr.toLowerCase().includes('network') || errorStr.toLowerCase().includes('fetch')) {\n            errorMessage = 'Error de red. Verifica tu conexi√≥n a internet.';\n        } else {\n            errorMessage = 'No se pudo conectar. Verifica que el usuario est√© en vivo.';\n        }\n\n        res.status(500).json({ success: false, error: errorMessage, username });\n    }\n});\n\napp.post('/api/tiktok/stop/:username', async (req: Request, res: Response): Promise<void> => {\n    const username = req.params.username.replace('@', '');\n\n    if (activeConnections.has(username)) {\n        const conn = activeConnections.get(username)!;\n        try {\n            await conn.connection.disconnect();\n            conn.sseClients.forEach(client => {\n                try { client.end(); } catch (e) {}\n            });\n        } catch (error) {\n            console.error(`Error al desconectar ${username}:`, error);\n        }\n        activeConnections.delete(username);\n        console.log(`üõë [${username}] Desconectado`);\n        res.json({ success: true, message: `Desconectado de @${username}`, username });\n        return;\n    }\n\n    res.json({ success: false, message: 'No hay conexi√≥n activa', username });\n});\n\napp.get('/api/tiktok/comments/:username', (req: Request, res: Response): void => {\n    const username = req.params.username.replace('@', '');\n    const conn = activeConnections.get(username);\n\n    if (conn) {\n        res.json({ success: true, comments: conn.comments, username });\n    } else {\n        res.status(404).json({ success: false, comments: [], username });\n    }\n});\n\napp.get('/api/tiktok/gifts/:username', (req: Request, res: Response): void => {\n    const username = req.params.username.replace('@', '');\n    const conn = activeConnections.get(username);\n\n    if (conn) {\n        res.json({ success: true, gifts: conn.gifts, username });\n    } else {\n        res.status(404).json({ success: false, gifts: [], username });\n    }\n});\n\napp.get('/api/tiktok/stats/:username', (req: Request, res: Response): void => {\n    const username = req.params.username.replace('@', '');\n    const conn = activeConnections.get(username);\n\n    if (conn) {\n        res.json({ success: true, stats: conn.roomStats, isConnected: conn.isConnected, username });\n    } else {\n        res.status(404).json({ success: false, stats: null, username });\n    }\n});\n\napp.get('/api/tiktok/status', (_req: Request, res: Response): void => {\n    const users = Array.from(activeConnections.entries()).map(([username, conn]) => ({\n        username,\n        isConnected: conn.isConnected,\n        stats: conn.roomStats,\n        commentsCount: conn.comments.length,\n        giftsCount: conn.gifts.length\n    }));\n    res.json({ success: true, users, count: users.length });\n});\n\napp.post('/api/tiktok/stop-all', async (_req: Request, res: Response): Promise<void> => {\n    const usernames = Array.from(activeConnections.keys());\n\n    for (const username of usernames) {\n        const conn = activeConnections.get(username);\n        if (conn) {\n            try {\n                await conn.connection.disconnect();\n                conn.sseClients.forEach(client => {\n                    try { client.end(); } catch (e) {}\n                });\n            } catch (error) {\n                console.error(`Error al desconectar ${username}:`, error);\n            }\n        }\n    }\n\n    activeConnections.clear();\n    res.json({ success: true, message: 'Todas las conexiones cerradas', stopped: usernames });\n});\n\napp.get('/api/tts/voices', async (_req: Request, res: Response): Promise<void> => {\n    try {\n        const voices = await ttsService.getAvailableVoices();\n        res.json({ success: true, voices });\n    } catch (error) {\n        console.error('Error al obtener voces:', error);\n        res.status(500).json({ success: false, error: 'Error al obtener voces', voices: [] });\n    }\n});\n\napp.post('/api/tts/speak', async (req: Request, res: Response): Promise<void> => {\n    try {\n        const { text, voiceId, provider, speed, volume } = req.body;\n\n        if (!text || !voiceId) {\n            res.status(400).json({ success: false, error: 'Texto y voiceId son requeridos' });\n            return;\n        }\n\n        const audioUrl = await ttsService.generateSpeech(text, voiceId, provider, {\n            speed: speed || 1.0,\n            volume: volume || 1.0,\n        });\n\n        res.json({ success: true, audioUrl, format: 'mp3' });\n    } catch (error) {\n        console.error('Error al generar speech:', error);\n        const errorMessage = error instanceof Error ? error.message : 'Error al generar speech';\n        res.status(500).json({ success: false, error: errorMessage });\n    }\n});\n\napp.get('/widget/chat/:username', (_req: Request, res: Response): void => {\n    res.sendFile(path.join(process.cwd(), 'public', 'widgets', 'chat.html'));\n});\n\napp.get('/widget/alerts/:username', (_req: Request, res: Response): void => {\n    res.sendFile(path.join(process.cwd(), 'public', 'widgets', 'alerts.html'));\n});\n\napp.get('/widget/goals/:username', (_req: Request, res: Response): void => {\n    res.sendFile(path.join(process.cwd(), 'public', 'widgets', 'goals.html'));\n});\n\nconst port = typeof PORT === 'string' ? parseInt(PORT, 10) : PORT;\napp.listen(port, '0.0.0.0', () => {\n    console.log(`\\nüöÄ Servidor corriendo en http://0.0.0.0:${PORT}`);\n    console.log(`üì° Listo para recibir conexiones de TikTok\\n`);\n});\n","path":null,"size_bytes":17960,"size_tokens":null}},"version":2}